# Deploy to Raspberry Pi via Cloudflare Tunnel
#
# Required secrets:
#  - PI_CLOUDFLARE_HOSTNAME: The hostname for SSH access via Cloudflare Tunnel (e.g., ssh.yourdomain.com)
#  - PI_USERNAME: The SSH username for the Raspberry Pi
#  - DOCKERHUB_USERNAME: Your Docker Hub username
#  - DOCKERHUB_TOKEN: Your Docker Hub access token
#  - SSH_PRIVATE_KEY: Private key for SSH access
#  - SSH_KNOWN_HOSTS: Known hosts file content

name: Deploy to Raspberry Pi

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy'
        required: false # allows for manual re-deployment
        default: 'latest'

env:
  DOCKERHUB_REPO: ${{ secrets.DOCKERHUB_USERNAME }}/balanced

jobs:
  lint:
    name: Lint and Type Check the source code
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Type checking
        run: npm run typecheck

  test:
    name: Run Tests on the source code
    needs: lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm run test

  build:
    name: Build Docker Image
    needs: [lint, test]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU for multi-architecture builds
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKERHUB_REPO }}
          tags: |
            type=semver,pattern={{version}}
            type=sha,format=long
            type=ref,event=branch
            type=raw,value={{date 'YYYYMMDD-HHmmss'}}
            latest

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.prod
          # push: ${{ github.event_name != 'pull_request' }} # only push new image on push, not on pull request to master
          push: true
          platforms: linux/amd64,linux/arm64 # For x86_64 PCs and Raspberry Pi 3/4/5 with 64-bit OS
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.DOCKERHUB_REPO }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKERHUB_REPO }}:buildcache,mode=max

  deploy:
    name: Deploy to Raspberry Pi
    needs: build
    runs-on: ubuntu-latest
    # only deploy on push, not on pull request
    # if: github.ref == 'refs/heads/master' && github.event_name != 'pull_request'
    steps:
      - name: Install cloudflared on GitHub runner
        run: |
          # Download and install cloudflared on the GitHub runner
          curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared.deb
          cloudflared --version

      - name: Install private SSH key on GitHub runner to enable SSH connection to Raspberry Pi
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          known_hosts: ${{ secrets.SSH_KNOWN_HOSTS }}
          if_key_exists: fail # Replace with "replace" if you want to replace it

      - name: Pull Docker image on Raspberry Pi
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          # Login to Docker Hub and pull the image on the Pi via Cloudflare Tunnel
          echo "Starting Docker image pull on Raspberry Pi"

          # Establish SSH connection through cloudflared
          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            echo 'Starting Docker Hub login'
            docker login -u $DOCKERHUB_USERNAME -p $DOCKERHUB_TOKEN
            
            echo 'Pulling image from Docker Hub: ${{ env.DOCKERHUB_REPO }}:latest'
            # Force platform to linux/arm64 for Raspberry Pi compatibility
            docker pull --platform linux/arm64 ${{ env.DOCKERHUB_REPO }}:latest
            
            # Verify image was pulled successfully
            echo 'Listing available Docker images after pull:'
            docker images | grep ${{ env.DOCKERHUB_REPO }}
          "
          echo "Docker image pull completed"

      - name: Tag Docker image with timestamp
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          # Create a timestamped tag for versioning
          echo "Creating timestamped tag for deployment tracking"

          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            # Generate timestamp for version tagging
            TIMESTAMP=\$(date +%Y%m%d%H%M%S)
            echo 'Creating tag with timestamp: '\${TIMESTAMP}
            
            # Tag the image with the timestamp
            docker tag --platform=linux/arm64 ${{ env.DOCKERHUB_REPO }}:latest ${{ env.DOCKERHUB_REPO }}:\${TIMESTAMP}
            
            # Verify tag was created and save timestamp for later use
            echo 'Verifying tagged image:'
            docker images | grep ${{ env.DOCKERHUB_REPO }}
            
            # Save timestamp for use in later deployment steps
            echo \${TIMESTAMP} > /tmp/deploy_timestamp
            echo 'Deployment timestamp saved: '\$(cat /tmp/deploy_timestamp)
          "

      # Note: Make sure to add the PI_CLOUDFLARE_HOSTNAME secret in GitHub repository settings
      # This should be the hostname created by Cloudflare Tunnel (e.g., ssh.yourdomain.com)
      - name: Prepare for blue-green deployment
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          # Set up blue-green deployment port configuration
          echo "Preparing for blue-green deployment"

          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            echo 'Checking for existing application container...'
            CURRENT_CONTAINER=\$(docker ps -q -f name=balanced-app)
            
            # Show running containers for debugging
            echo 'Currently running containers:'
            docker ps
            
            # Determine ports for blue-green deployment
            echo 'Setting up blue-green deployment ports'
            if [ -z \"\$CURRENT_CONTAINER\" ]; then
              echo 'No existing container found, using default ports'
              echo '3000' > /tmp/new_port
              echo '3001' > /tmp/old_port
            else
              echo 'Existing container found: '\$CURRENT_CONTAINER
              # Check which port the current container is using
              CURRENT_PORT=\$(docker port \$CURRENT_CONTAINER | grep -o '0.0.0.0:3000' | wc -l)
              if [ \"\$CURRENT_PORT\" -gt 0 ]; then
                echo 'Current container uses port 3000, new container will use port 3001'
                echo '3001' > /tmp/new_port
                echo '3000' > /tmp/old_port
              else
                echo 'Current container uses port 3001, new container will use port 3000'
                echo '3000' > /tmp/new_port
                echo '3001' > /tmp/old_port
              fi
            fi
            
            echo 'Selected ports:'
            echo 'New container port: '\$(cat /tmp/new_port)
            echo 'Old container port: '\$(cat /tmp/old_port)
            
            # Copy volume configuration from existing container if available
            if [ ! -z \"\$CURRENT_CONTAINER\" ]; then
              echo 'Extracting volume configuration from current container'
              # Get volume mapping from current container
              docker inspect -f '{{range .Mounts}}{{.Source}}:{{.Destination}} {{end}}' \$CURRENT_CONTAINER > /tmp/container_volumes
              echo 'Volume configuration saved:'
              cat /tmp/container_volumes
              
              # Save current container ID for later use
              echo \$CURRENT_CONTAINER > /tmp/current_container_id
              echo 'Current container ID saved: '\$(cat /tmp/current_container_id)
            else
              echo 'No existing container, no volumes to preserve'
            fi
            "
          echo "Blue-green deployment preparation completed"

      - name: Deploy new container
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL }}
        run: |
          # Deploy the new container with the proper configuration
          echo "Starting deployment of new container"

          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            # Load saved values from previous steps
            TIMESTAMP=\$(cat /tmp/deploy_timestamp)
            NEW_PORT=\$(cat /tmp/new_port)
            
            echo 'Deploying new container with timestamp: '\$TIMESTAMP
            echo 'Container will use internal port: '\$NEW_PORT
            
            # Set up volume arguments if needed
            echo 'Setting up volume configuration'
            VOLUME_ARGS=\"\"
            if [ -f /tmp/container_volumes ]; then
              VOLUMES=\$(cat /tmp/container_volumes)
              if [ ! -z \"\$VOLUMES\" ]; then
                echo 'Using volumes from previous container:'
                for VOLUME in \$VOLUMES; do
                  echo '  - '\$VOLUME
                  VOLUME_ARGS=\"\$VOLUME_ARGS -v \$VOLUME\"
                done
              else
                echo 'No volumes found in configuration file'
              fi
            else
              echo 'No volume configuration file found'
            fi
            
            # Debug container deployment
            echo 'Available images:'
            docker images
            
            # Run the new container with the correct image name and explicit platform
            echo 'Running container with image ${{ env.DOCKERHUB_REPO }}:'\${TIMESTAMP}
            docker run --platform=linux/arm64 -d \
              --name balanced-app-new \
              --restart unless-stopped \
              -p 3000:\$NEW_PORT \
              -e DATABASE_URL='$DATABASE_URL' \
              -e NEXTAUTH_SECRET='$NEXTAUTH_SECRET' \
              -e NEXTAUTH_URL='$NEXTAUTH_URL' \
              \$VOLUME_ARGS \
              ${{ env.DOCKERHUB_REPO }}:\${TIMESTAMP}
            
            # Verify container was created successfully
            echo 'New container created:'
            docker ps | grep balanced-app-new
          "
          echo "New container deployment completed"

      - name: Health check and finalize deployment
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          # Verify the new container is healthy before switching
          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            # Wait for the new container to be healthy
            echo 'Waiting for new container to be ready...'
            timeout=30
            # Wait for the new container to be healthy
            echo 'Waiting for new container to be ready...'
            timeout=30
            while [ \$timeout -gt 0 ]; do
              if curl -s http://localhost:3000 > /dev/null; then
                echo 'New container is ready'
                break
              fi
              echo 'Waiting for service to start...'
              sleep 2
              timeout=\$((timeout-2))
            done

            # Switch to new container if healthy
            if [ \$timeout -gt 0 ]; then
              if [ -f /tmp/current_container_id ]; then
                CURRENT_CONTAINER=\$(cat /tmp/current_container_id)
                docker stop \$CURRENT_CONTAINER
                docker rm \$CURRENT_CONTAINER
              fi

              # Rename the new container to the standard name
              docker rename balanced-app-new balanced-app
              echo 'Deployment successful'
            else
              # Rollback if new container fails health check
              echo 'New container failed to start properly'
              docker stop balanced-app-new
              docker rm balanced-app-new
              echo 'Deployment failed - rolling back'
              exit 1
            fi
          "

      - name: Cleanup
        if: always() # Run cleanup even if previous steps fail
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          # Clean up temporary files and old images
          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            # Remove the temporary image file
            rm /tmp/balanced-image.tar

            # Clean up temporary files
            rm -f /tmp/deploy_timestamp
            rm -f /tmp/new_port
            rm -f /tmp/old_port
            rm -f /tmp/container_volumes
            rm -f /tmp/current_container_id

            # Clean up old images (keep only the 3 most recent)
            docker image ls balanced --format '{{.Tag}}' | sort -r | tail -n +4 | xargs -I {} docker rmi balanced:{} || true
          "
