# Deploy to Raspberry Pi via Cloudflare Tunnel
#
# Required secrets:
#  - PI_CLOUDFLARE_HOSTNAME: The hostname for SSH access via Cloudflare Tunnel (e.g., ssh.yourdomain.com)
#  - PI_USERNAME: The SSH username for the Raspberry Pi
#  - DOCKERHUB_USERNAME: Your Docker Hub username
#  - DOCKERHUB_TOKEN: Your Docker Hub access token
#  - SSH_PRIVATE_KEY: Private key for SSH access
#  - SSH_KNOWN_HOSTS: Known hosts file content

name: Deploy to Raspberry Pi

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy'
        required: false # allows for manual re-deployment
        default: 'latest'

env:
  DOCKERHUB_REPO: ${{ secrets.DOCKERHUB_USERNAME }}/balanced

jobs:
  lint:
    name: Lint and Type Check the source code
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Type checking
        run: npm run typecheck

  test:
    name: Run Tests on the source code
    needs: lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm run test

  build:
    name: Build Docker Image
    needs: [lint, test]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU for multi-architecture builds
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKERHUB_REPO }}
          tags: |
            type=semver,pattern={{version}}
            type=sha,format=long
            type=ref,event=branch
            type=raw,value={{date 'YYYYMMDD-HHmmss'}}
            latest

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.prod
          # push: ${{ github.event_name != 'pull_request' }} # only push new image on push, not on pull request to master
          push: true
          platforms: linux/amd64,linux/arm64 # For x86_64 PCs and Raspberry Pi 3/4/5 with 64-bit OS
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.DOCKERHUB_REPO }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKERHUB_REPO }}:buildcache,mode=max

  deploy:
    name: Deploy to Raspberry Pi
    needs: build
    runs-on: ubuntu-latest
    # only deploy on push, not on pull request
    # if: github.ref == 'refs/heads/master' && github.event_name != 'pull_request'
    steps:
      - name: Install cloudflared on GitHub runner
        run: |
          # Download and install cloudflared on the GitHub runner
          curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared.deb
          cloudflared --version

      - name: Install private SSH key on GitHub runner to enable SSH connection to Raspberry Pi
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          known_hosts: ${{ secrets.SSH_KNOWN_HOSTS }}
          if_key_exists: fail # Replace with "replace" if you want to replace it

      - name: Pull Docker image on Raspberry Pi
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          # Login to Docker Hub and pull the image on the Pi via Cloudflare Tunnel
          echo "Starting Docker image pull on Raspberry Pi"

          # Establish SSH connection through cloudflared
          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            echo 'Starting Docker Hub login'
            docker login -u $DOCKERHUB_USERNAME -p $DOCKERHUB_TOKEN

            echo 'Pulling image from Docker Hub: ${{ env.DOCKERHUB_REPO }}:latest'
            # Force platform to linux/arm64 for Raspberry Pi compatibility
            docker pull --platform linux/arm64 ${{ env.DOCKERHUB_REPO }}:latest

            # Verify image was pulled successfully
            echo 'Listing available Docker images after pull:'
            docker images | grep ${{ env.DOCKERHUB_REPO }}
          "
          echo "Docker image pull completed"

      - name: Tag Docker image with timestamp
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          # Create a timestamped tag for versioning
          echo "Creating timestamped tag for deployment tracking"

          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            # Generate timestamp for version tagging
            TIMESTAMP=\$(date +%Y%m%d%H%M%S)
            echo 'Creating tag with timestamp: '\${TIMESTAMP}

            # Tag the image with the timestamp
            # Note: docker tag doesn't support the --platform flag
            docker tag ${{ env.DOCKERHUB_REPO }}:latest ${{ env.DOCKERHUB_REPO }}:\${TIMESTAMP}

            # Verify tag was created and save timestamp for later use
            echo 'Verifying tagged image:'
            docker images | grep ${{ env.DOCKERHUB_REPO }}

            # Save timestamp for use in later deployment steps
            echo \${TIMESTAMP} > /tmp/deploy_timestamp
            echo 'Deployment timestamp saved: '\$(cat /tmp/deploy_timestamp)
          "

      # Note: Make sure to add the PI_CLOUDFLARE_HOSTNAME secret in GitHub repository settings
      # This should be the hostname created by Cloudflare Tunnel (e.g., ssh.yourdomain.com)
      - name: Prepare for blue-green deployment
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          # Set up blue-green deployment port configuration
          echo "Preparing for blue-green deployment"

          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            echo 'Checking for existing application container...'
            CURRENT_CONTAINER=\$(docker ps -q -f name=balanced-app)

            # Show running containers for debugging
            echo 'Currently running containers:'
            docker ps

            # Determine ports for blue-green deployment
            echo 'Setting up blue-green deployment ports'
            if [ -z \"\$CURRENT_CONTAINER\" ]; then
              echo 'No existing container found, using default ports'
              echo '3000' > /tmp/new_port
              echo '3001' > /tmp/old_port
            else
              echo 'Existing container found: '\$CURRENT_CONTAINER
              # Check which port the current container is using
              CURRENT_PORT=\$(docker port \$CURRENT_CONTAINER | grep -o '0.0.0.0:3000' | wc -l)
              if [ \"\$CURRENT_PORT\" -gt 0 ]; then
                echo 'Current container uses port 3000, new container will use port 3001'
                echo '3001' > /tmp/new_port
                echo '3000' > /tmp/old_port
              else
                echo 'Current container uses port 3001, new container will use port 3000'
                echo '3000' > /tmp/new_port
                echo '3001' > /tmp/old_port
              fi
            fi

            echo 'Selected ports:'
            echo 'New container port: '\$(cat /tmp/new_port)
            echo 'Old container port: '\$(cat /tmp/old_port)

            # Copy volume configuration from existing container if available
            if [ ! -z \"\$CURRENT_CONTAINER\" ]; then
              echo 'Extracting volume configuration from current container'
              # Get volume mapping using a variable to protect template syntax
              TEMPLATE='{{"{{"}range .Mounts}}{{"{{"}}{{"."}}}Source}:{{"{{"}}{{"."}}}Destination}} {{"{{"}}end}}'
              docker inspect -f "\$TEMPLATE" "\$CURRENT_CONTAINER" > /tmp/container_volumes
              echo 'Volume configuration saved:'
              cat /tmp/container_volumes

              # Save current container ID for later use
              echo \$CURRENT_CONTAINER > /tmp/current_container_id
              echo 'Current container ID saved: '\$(cat /tmp/current_container_id)
            else
              echo 'No existing container, no volumes to preserve'
            fi
            "
          echo "Blue-green deployment preparation completed"

      - name: Deploy new container
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL }}
        run: |
          # Deploy the new container with the proper configuration
          echo "Starting deployment of new container"

          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              -o ServerAliveInterval=30 \
              -o ServerAliveCountMax=3 \
              -o ConnectTimeout=10 \
              -o TCPKeepAlive=yes \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            # Load saved values from previous steps
            TIMESTAMP=\$(cat /tmp/deploy_timestamp)
            NEW_PORT=\$(cat /tmp/new_port)

            echo 'Deploying new container with timestamp: '\$TIMESTAMP
            echo 'Container will use internal port: '\$NEW_PORT

            # Set up volume arguments if needed
            echo 'Setting up volume configuration'
            VOLUME_ARGS=\"\"
            if [ -f /tmp/container_volumes ]; then
              VOLUMES=\$(cat /tmp/container_volumes)
              if [ ! -z \"\$VOLUMES\" ]; then
                echo 'Using volumes from previous container:'
                for VOLUME in \$VOLUMES; do
                  echo '  - '\$VOLUME
                  VOLUME_ARGS=\"\$VOLUME_ARGS -v \$VOLUME\"
                done
              else
                echo 'No volumes found in configuration file'
              fi
            else
              echo 'No volume configuration file found'
            fi

            # Debug container deployment
            echo 'Available images:'
            docker images

            # Run the new container with the correct image name and explicit platform
            echo 'Running container with the locally tagged image: ${{ env.DOCKERHUB_REPO }}:'\${TIMESTAMP}

            # Debug: Confirm the locally tagged image exists before trying to use it
            echo 'Confirming image exists:'
            # Check if image exists
            IMAGE_EXISTS=0
            docker images "${{ env.DOCKERHUB_REPO }}:\${TIMESTAMP}" --quiet | grep -q . || IMAGE_EXISTS=1

            # Check if image exists using our helper script result
            if [ "\$IMAGE_EXISTS" -eq 0 ]; then
              echo 'Image found locally, proceeding with deployment'

              docker run --platform=linux/arm64 -d \
                --name balanced-app-new \
                --restart unless-stopped \
                -p 3000:\$NEW_PORT \
                -e DATABASE_URL='$DATABASE_URL' \
                -e NEXTAUTH_SECRET='$NEXTAUTH_SECRET' \
                -e NEXTAUTH_URL='$NEXTAUTH_URL' \
                \$VOLUME_ARGS \
                ${{ env.DOCKERHUB_REPO }}:\${TIMESTAMP}

              if [ $? -eq 0 ]; then
                echo 'Container started successfully'
              else
                echo 'Error starting container'
                exit 1
              fi
            else
              echo '[ERROR] Tagged image not found locally. This likely indicates a problem with the tagging step.'
              echo 'Available images:'
              docker images
              exit 1
            fi

            # Verify container was created successfully
            echo 'New container created:'
            docker ps | grep balanced-app-new
          "
          echo "New container deployment completed"

      - name: Health check
        id: health_check
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          echo "Running container health check"

          # Verify the new container is healthy using the dedicated health endpoint
          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "set -e

            # First check if container is running
            echo 'Checking if container exists and is running...'
            if ! docker ps | grep -q balanced-app-new; then
              echo '[ERROR] Container balanced-app-new is not running'
              echo 'Container status:'
              docker ps -a | grep balanced-app-new || echo 'Container does not exist'

              if docker ps -a | grep -q balanced-app-new; then
                echo 'Container logs:'
                docker logs balanced-app-new
              fi

              echo 'Cleaning up failed container...'
              docker rm -f balanced-app-new 2>/dev/null || true
              exit 1
            fi

            echo '[SUCCESS] Container is running, performing health check...'

            # Get port mapping info
            NEW_PORT=\$(cat /tmp/new_port 2>/dev/null || echo '3000')
            echo 'Container mapped to internal port: '\$NEW_PORT

            # Health check using dedicated endpoint with retry logic
            echo 'Checking application health (2 minute timeout)...'
            echo "Expected health endpoint: http://localhost:\$NEW_PORT/api/health"
            
            # Show initial container state
            echo 'Initial container state:'
            docker ps --filter name=balanced-app-new --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.CreatedAt}}'
            
            # Check if port is actually listening
            echo "Checking if port \$NEW_PORT is listening..."
            netstat -tlnp | grep :\$NEW_PORT || echo "Port \$NEW_PORT is not listening"
            
            HEALTH_CHECK_PASSED=false

            for attempt in {1..12}; do
              echo "\n=== Health check attempt \$attempt/12 ==="
              
              # Use curl to get health status and check for 'ok' status
              echo "Attempting to connect to: http://localhost:\$NEW_PORT/api/health"
              HEALTH_RESPONSE=\$(curl -s -w "HTTP_CODE:%{http_code}" --connect-timeout 5 --max-time 10 http://localhost:\$NEW_PORT/api/health 2>&1)
              CURL_EXIT_CODE=\$?
              
              echo "Curl exit code: \$CURL_EXIT_CODE"
              echo "Curl response: \$HEALTH_RESPONSE"
              
              # Decode curl exit codes for better debugging
              case \$CURL_EXIT_CODE in
                0) echo "Curl status: Success" ;;
                7) echo "Curl status: Failed to connect to host" ;;
                28) echo "Curl status: Operation timeout" ;;
                52) echo "Curl status: Empty reply from server" ;;
                56) echo "Curl status: Failure in receiving network data" ;;
                *) echo "Curl status: Unknown error (code \$CURL_EXIT_CODE)" ;;
              esac
              
              if [ \$CURL_EXIT_CODE -eq 0 ] && echo "\$HEALTH_RESPONSE" | grep -q '"status":"ok"'; then
                echo '[SUCCESS] Health check passed!'
                HEALTH_CHECK_PASSED=true
                break
              else
                echo "Health check failed (curl exit code: \$CURL_EXIT_CODE), waiting 10 seconds..."

                # Show detailed diagnostics every few attempts
                if [ \$((attempt % 3)) -eq 0 ]; then
                  echo '\n--- Diagnostic Information ---'
                  echo 'Container status:'
                  docker ps --filter name=balanced-app-new --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.RunningFor}}'
                  
                  echo 'Port status:'
                  netstat -tlnp | grep :\$NEW_PORT || echo "Port \$NEW_PORT is not listening"
                  
                  echo 'Recent container logs (last 10 lines):'
                  docker logs --tail=10 balanced-app-new 2>/dev/null || echo 'No logs available'
                  
                  echo 'Container resource usage:'
                  docker stats --no-stream --format 'table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}' balanced-app-new 2>/dev/null || echo 'Stats unavailable'
                  echo '--- End Diagnostics ---\n'
                fi

                sleep 10
              fi
            done

            # Final result
            if [ "\$HEALTH_CHECK_PASSED" = "true" ]; then
              echo '[SUCCESS] Application is healthy and ready!'
              echo 'Final container status:'
              docker ps --filter name=balanced-app-new --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'
              exit 0
            else
              echo '\n[ERROR] Health check failed after 2 minutes'
              echo '\n=== FAILURE DIAGNOSTICS ==='
              
              echo 'Final container status:'
              docker ps -a --filter name=balanced-app-new --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.RunningFor}}\t{{.Size}}'
              
              echo '\nContainer inspect (relevant fields):'
              docker inspect balanced-app-new --format='{{.State.Status}} | {{.State.ExitCode}} | {{.State.Error}} | {{.State.StartedAt}}' 2>/dev/null || echo 'Inspect failed'
              
              echo '\nPort binding details:'
              docker port balanced-app-new 2>/dev/null || echo 'No port bindings found'
              
              echo '\nSystem port status:'
              netstat -tlnp | grep :\$NEW_PORT || echo "Port \$NEW_PORT is not listening"
              
              echo '\nComplete container logs:'
              docker logs balanced-app-new 2>&1 || echo 'No logs available'
              
              echo '\nContainer environment variables:'
              docker exec balanced-app-new env 2>/dev/null | grep -E '(NODE_ENV|PORT|DATABASE_URL)' || echo 'Could not retrieve env vars'
              
              echo '=== END DIAGNOSTICS ===\n'

              echo 'Cleaning up failed deployment...'
              docker stop balanced-app-new || true
              docker rm balanced-app-new || true
              exit 1
            fi
          "

      - name: Finalize deployment
        if: success() && steps.health_check.outcome == 'success'
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          echo "Finalizing successful deployment"

          # Deploy the new container with improved SSH stability
          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              -o ServerAliveInterval=30 \
              -o ServerAliveCountMax=3 \
              -o ConnectTimeout=10 \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "set -e

            # Get port mapping info (for logging purposes)
            NEW_PORT=\$(cat /tmp/new_port 2>/dev/null || echo '3000')
            echo 'Container mapped to internal port: '\$NEW_PORT

            # Clean up old container if it exists
            if [ -f /tmp/current_container_id ]; then
              CURRENT_CONTAINER=\$(cat /tmp/current_container_id)
              echo 'Stopping previous container: '\$CURRENT_CONTAINER

              # Stop with timeout and remove
              docker stop --time=10 \$CURRENT_CONTAINER || true
              docker rm \$CURRENT_CONTAINER || echo '[WARNING] Could not remove old container'
              echo 'Old container removed'
            else
              echo 'No previous container found'
            fi

            # Rename new container to standard name
            echo 'Setting new container as primary'
            docker rename balanced-app-new balanced-app
            if [ \$? -eq 0 ]; then
              echo '[SUCCESS] DEPLOYMENT SUCCESSFUL'
              echo 'Application is now running'
            else
              echo '[WARNING] Could not rename container - verify manually'
              # Don't fail the build for rename issue
            fi
          "

      - name: Clean-up
        if: always() # Run cleanup even if previous steps fail
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          echo "Performing post-deployment cleanup"

          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            echo 'Running post-deployment cleanup...'

            # Remove temporary image file if it exists
            rm -f /tmp/balanced-image.tar

            # Clean up all temporary files
            echo 'Removing temporary files'
            rm -f /tmp/deploy_timestamp /tmp/new_port /tmp/old_port /tmp/container_volumes /tmp/current_container_id

            # Clean up old images (keep only the 3 most recent)
            echo 'Cleaning up old Docker images (keeping 3 most recent)'
            REPO='${{ env.DOCKERHUB_REPO }}'

            # Use heredoc approach for Docker template syntax
            cat << 'EOT' > /tmp/list_tags.sh
            #!/bin/bash
            # Get tags using Docker's native template formatting
            docker images "$1" --format '{{.Tag}}' | grep -v 'latest' | grep -v '<none>' | sort -r
            EOT
            chmod +x /tmp/list_tags.sh
            TAGS=\$(/tmp/list_tags.sh "\$REPO")
            rm /tmp/list_tags.sh
            COUNT=\$(echo "\$TAGS" | wc -l)

            if [ \$COUNT -gt 3 ]; then
              echo "Found \$COUNT tags, removing old ones"
              echo "\$TAGS" | tail -n +4 | xargs -r -I {} docker rmi \$REPO:{} 2>/dev/null || true
              echo '[SUCCESS] Image clean-up completed'
            else
              echo "Only \$COUNT tagged images found, no clean-up needed"
            fi

            # General clean-up of dangling images
            echo 'Removing any dangling images'
            docker image prune -f

            echo '[SUCCESS] Cleanup completed successfully'
          "
