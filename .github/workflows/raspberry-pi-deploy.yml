# Deploy to Raspberry Pi via Cloudflare Tunnel
name: Deploy to Raspberry Pi

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy'
        required: false # allows for manual re-deployment
        default: 'latest'

env:
  DOCKERHUB_REPO: ${{ secrets.DOCKERHUB_USERNAME }}/balanced

jobs:
  lint:
    name: Lint the source code
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

  typecheck:
    name: Type check the source code
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run type checking
        run: npm run typecheck

  test:
    name: Run tests on the source code
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm run test

  build:
    name: Build And Push Docker Image
    needs: [test, lint, typecheck]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU for multi-architecture builds
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKERHUB_REPO }}
          tags: |
            type=semver,pattern={{version}}
            type=sha,format=long
            type=ref,event=branch
            type=raw,value={{date 'YYYYMMDD-HHmmss'}}
            latest

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.prod
          # push: ${{ github.event_name != 'pull_request' }} # only push new image on push, not on pull request to master
          push: true
          platforms: linux/amd64,linux/arm64 # For x86_64 PCs and Raspberry Pi 3/4/5 with 64-bit OS
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.DOCKERHUB_REPO }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKERHUB_REPO }}:buildcache,mode=max

  deploy:
    name: Deploy to Raspberry Pi
    needs: build
    runs-on: ubuntu-latest
    # only deploy on push, not on pull request
    # if: github.ref == 'refs/heads/master' && github.event_name != 'pull_request'
    steps:
      - name: Install cloudflared on GitHub runner
        run: |
          # Download and install cloudflared on the GitHub runner
          curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared.deb
          cloudflared --version

      - name: Install private SSH key on GitHub runner to enable SSH connection to Raspberry Pi
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          known_hosts: ${{ secrets.SSH_KNOWN_HOSTS }}
          if_key_exists: fail # Replace with "replace" if you want to replace it

      - name: Pull Docker image on Raspberry Pi
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          # Login to Docker Hub and pull the image on the Pi via Cloudflare Tunnel
          echo "Starting Docker image pull on Raspberry Pi"

          # Establish SSH connection through cloudflared
          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            echo 'Starting Docker Hub login'
            docker login -u $DOCKERHUB_USERNAME -p $DOCKERHUB_TOKEN

            echo 'Pulling image from Docker Hub: ${{ env.DOCKERHUB_REPO }}:latest'
            # Force platform to linux/arm64 for Raspberry Pi compatibility
            docker pull --platform linux/arm64 ${{ env.DOCKERHUB_REPO }}:latest

            # Verify image was pulled successfully
            echo 'Listing available Docker images after pull:'
            docker images | grep ${{ env.DOCKERHUB_REPO }}
          "
          echo "Docker image pull completed"

      - name: Tag Docker image with timestamp
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          # Create a timestamped tag for versioning
          echo "Creating timestamped tag for deployment tracking"

          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            # Generate timestamp for version tagging
            TIMESTAMP=\$(date +%Y%m%d%H%M%S)
            echo 'Creating tag with timestamp: '\${TIMESTAMP}

            # Tag the image with the timestamp
            # Note: docker tag doesn't support the --platform flag
            docker tag ${{ env.DOCKERHUB_REPO }}:latest ${{ env.DOCKERHUB_REPO }}:\${TIMESTAMP}

            # Verify tag was created and save timestamp for later use
            echo 'Verifying tagged image:'
            docker images | grep ${{ env.DOCKERHUB_REPO }}

            # Save timestamp for use in later deployment steps
            echo \${TIMESTAMP} > /tmp/deploy_timestamp
            echo 'Deployment timestamp saved: '\$(cat /tmp/deploy_timestamp)
          "

      - name: Copy production files to Raspberry Pi
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          echo "Copying production configuration files to Raspberry Pi"

          # Copy essential configuration files
          scp -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              compose.prod.yml .env.production \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME:~/balanced-app/

          # Copy nginx configuration directory
          scp -r -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              src/services/nginx/ \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME:~/balanced-app/src/services/

          # Copy scripts directory (contains backup and startup scripts)
          scp -r -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              scripts/ \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME:~/balanced-app/

          echo "Production files and scripts copied successfully"

      - name: Deploy with Docker Compose
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          echo "Starting Docker Compose deployment"

          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "

            # Navigate to deployment directory
            cd ~/balanced-app

            # Create required directories
            mkdir -p certs nginx-logs backups static-html

            # Run blue-green deployment script
            chmod +x scripts/deploy-blue-green.sh
            ./scripts/deploy-blue-green.sh
          "

      - name: Health check
        id: health_check
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          echo "Starting container health check"

          # Verify the Docker Compose services are healthy
          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "

            cd ~/balanced-app

            # Run health check script
            chmod +x scripts/health-check.sh
            ./scripts/health-check.sh
          "

      - name: Finalize deployment
        if: success() && steps.health_check.outcome == 'success'
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          echo "Finalizing successful deployment"

          # Finalize Docker Compose deployment
          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "

            cd ~/balanced-app

            echo 'Verifying final deployment status...'
            docker compose -f compose.prod.yml ps

            echo 'Checking service health...'
            if docker compose -f compose.prod.yml ps | grep -q 'Up'; then
              echo 'SUCCESS: DEPLOYMENT SUCCESSFUL'
              echo 'All services are running'
              echo 'Application is accessible via nginx proxy'
            else
              echo 'WARNING: Some services may not be running properly'
              docker compose -f compose.prod.yml logs --tail=20
            fi
          "

      - name: Clean-up
        if: always() # Run cleanup even if previous steps fail
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          echo "Performing post-deployment cleanup"

          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            echo 'Running post-deployment cleanup...'

            # Remove temporary image file if it exists
            rm -f /tmp/balanced-image.tar

            # Clean up all temporary files
            echo 'Removing temporary files'
            rm -f /tmp/deploy_timestamp /tmp/new_port /tmp/old_port /tmp/container_volumes /tmp/current_container_id

            # Clean up old images (keep only the 3 most recent)
            echo 'Cleaning up old Docker images (keeping 3 most recent)'
            REPO='${{ env.DOCKERHUB_REPO }}'

            # Use heredoc approach for Docker template syntax
            cat << 'EOT' > /tmp/list_tags.sh
            #!/bin/bash
            # Get tags using simple docker images command
            docker images "$1" | awk 'NR>1 {print $2}' | grep -v 'latest' | grep -v '<none>' | sort -r
            EOT
            chmod +x /tmp/list_tags.sh
            TAGS=\$(/tmp/list_tags.sh "\$REPO")
            rm /tmp/list_tags.sh
            COUNT=\$(echo "\$TAGS" | wc -l)

            if [ \$COUNT -gt 3 ]; then
              echo "Found \$COUNT tags, removing old ones"
              echo "\$TAGS" | tail -n +4 | xargs -r -I {} docker rmi \$REPO:{} 2>/dev/null || true
              echo 'SUCCESS: Image clean-up completed'
            else
              echo "Only \$COUNT tagged images found, no clean-up needed"
            fi

            # General clean-up of dangling images
            echo 'Removing any dangling images'
            docker image prune -f

            echo 'SUCCESS: Cleanup completed successfully'
          "
