# Deploy to Raspberry Pi via Cloudflare Tunnel
#
# Required secrets:
#  - PI_CLOUDFLARE_HOSTNAME: The hostname for SSH access via Cloudflare Tunnel (e.g., ssh.yourdomain.com)
#  - PI_USERNAME: The SSH username for the Raspberry Pi
#  - DOCKERHUB_USERNAME: Your Docker Hub username
#  - DOCKERHUB_TOKEN: Your Docker Hub access token
#  - SSH_PRIVATE_KEY: Private key for SSH access
#  - SSH_KNOWN_HOSTS: Known hosts file content

name: Deploy to Raspberry Pi

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy'
        required: false # allows for manual re-deployment
        default: 'latest'

env:
  DOCKERHUB_REPO: ${{ secrets.DOCKERHUB_USERNAME }}/balanced

jobs:
  lint:
    name: Lint and Type Check the source code
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Type checking
        run: npm run typecheck

  test:
    name: Run Tests on the source code
    needs: lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm run test

  build:
    name: Build Docker Image
    needs: [lint, test]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU for multi-architecture builds
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKERHUB_REPO }}
          tags: |
            type=semver,pattern={{version}}
            type=sha,format=long
            type=ref,event=branch
            type=raw,value={{date 'YYYYMMDD-HHmmss'}}
            latest

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.prod
          # push: ${{ github.event_name != 'pull_request' }} # only push new image on push, not on pull request to master
          push: true
          platforms: linux/amd64,linux/arm64 # For x86_64 PCs and Raspberry Pi 3/4/5 with 64-bit OS
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.DOCKERHUB_REPO }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKERHUB_REPO }}:buildcache,mode=max

  deploy:
    name: Deploy to Raspberry Pi
    needs: build
    runs-on: ubuntu-latest
    # only deploy on push, not on pull request
    # if: github.ref == 'refs/heads/master' && github.event_name != 'pull_request'
    steps:
      - name: Install cloudflared on GitHub runner
        run: |
          # Download and install cloudflared on the GitHub runner
          curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared.deb
          cloudflared --version

      - name: Install private SSH key on GitHub runner to enable SSH connection to Raspberry Pi
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          known_hosts: ${{ secrets.SSH_KNOWN_HOSTS }}
          if_key_exists: fail # Replace with "replace" if you want to replace it

      - name: Pull Docker image on Raspberry Pi
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          # Login to Docker Hub and pull the image on the Pi via Cloudflare Tunnel
          echo "Starting Docker image pull on Raspberry Pi"

          # Establish SSH connection through cloudflared
          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            echo 'Starting Docker Hub login'
            docker login -u $DOCKERHUB_USERNAME -p $DOCKERHUB_TOKEN

            echo 'Pulling image from Docker Hub: ${{ env.DOCKERHUB_REPO }}:latest'
            # Force platform to linux/arm64 for Raspberry Pi compatibility
            docker pull --platform linux/arm64 ${{ env.DOCKERHUB_REPO }}:latest

            # Verify image was pulled successfully
            echo 'Listing available Docker images after pull:'
            docker images | grep ${{ env.DOCKERHUB_REPO }}
          "
          echo "Docker image pull completed"

      - name: Tag Docker image with timestamp
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          # Create a timestamped tag for versioning
          echo "Creating timestamped tag for deployment tracking"

          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            # Generate timestamp for version tagging
            TIMESTAMP=\$(date +%Y%m%d%H%M%S)
            echo 'Creating tag with timestamp: '\${TIMESTAMP}

            # Tag the image with the timestamp
            # Note: docker tag doesn't support the --platform flag
            docker tag ${{ env.DOCKERHUB_REPO }}:latest ${{ env.DOCKERHUB_REPO }}:\${TIMESTAMP}

            # Verify tag was created and save timestamp for later use
            echo 'Verifying tagged image:'
            docker images | grep ${{ env.DOCKERHUB_REPO }}

            # Save timestamp for use in later deployment steps
            echo \${TIMESTAMP} > /tmp/deploy_timestamp
            echo 'Deployment timestamp saved: '\$(cat /tmp/deploy_timestamp)
          "

      # Note: Make sure to add the PI_CLOUDFLARE_HOSTNAME secret in GitHub repository settings
      # This should be the hostname created by Cloudflare Tunnel (e.g., ssh.yourdomain.com)
      - name: Prepare for blue-green deployment
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          # Set up blue-green deployment port configuration
          echo "Preparing for blue-green deployment"

          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            echo 'Checking for existing application container...'
            CURRENT_CONTAINER=\$(docker ps -q -f name=balanced-app)

            # Show running containers for debugging
            echo 'Currently running containers:'
            docker ps

            # Determine ports for blue-green deployment
            echo 'Setting up blue-green deployment ports'
            if [ -z \"\$CURRENT_CONTAINER\" ]; then
              echo 'No existing container found, using default ports'
              echo '3000' > /tmp/new_port
              echo '3001' > /tmp/old_port
            else
              echo 'Existing container found: '\$CURRENT_CONTAINER
              # Check which port the current container is using
              CURRENT_PORT=\$(docker port \$CURRENT_CONTAINER | grep -o '0.0.0.0:3000' | wc -l)
              if [ \"\$CURRENT_PORT\" -gt 0 ]; then
                echo 'Current container uses port 3000, new container will use port 3001'
                echo '3001' > /tmp/new_port
                echo '3000' > /tmp/old_port
              else
                echo 'Current container uses port 3001, new container will use port 3000'
                echo '3000' > /tmp/new_port
                echo '3001' > /tmp/old_port
              fi
            fi

            echo 'Selected ports:'
            echo 'New container port: '\$(cat /tmp/new_port)
            echo 'Old container port: '\$(cat /tmp/old_port)

            # Copy volume configuration from existing container if available
            if [ ! -z \"\$CURRENT_CONTAINER\" ]; then
              echo 'Extracting volume configuration from current container'
              # Get volume mapping using a variable to protect template syntax
              TEMPLATE='{{"{{"}range .Mounts}}{{"{{"}}{{"."}}}Source}:{{"{{"}}{{"."}}}Destination}} {{"{{"}}end}}'
              docker inspect -f "\$TEMPLATE" "\$CURRENT_CONTAINER" > /tmp/container_volumes
              echo 'Volume configuration saved:'
              cat /tmp/container_volumes

              # Save current container ID for later use
              echo \$CURRENT_CONTAINER > /tmp/current_container_id
              echo 'Current container ID saved: '\$(cat /tmp/current_container_id)
            else
              echo 'No existing container, no volumes to preserve'
            fi
            "
          echo "Blue-green deployment preparation completed"

      - name: Deploy new container
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL }}
        run: |
          # Deploy the new container with the proper configuration
          echo "Starting deployment of new container"

          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            # Load saved values from previous steps
            TIMESTAMP=\$(cat /tmp/deploy_timestamp)
            NEW_PORT=\$(cat /tmp/new_port)

            echo 'Deploying new container with timestamp: '\$TIMESTAMP
            echo 'Container will use internal port: '\$NEW_PORT

            # Set up volume arguments if needed
            echo 'Setting up volume configuration'
            VOLUME_ARGS=\"\"
            if [ -f /tmp/container_volumes ]; then
              VOLUMES=\$(cat /tmp/container_volumes)
              if [ ! -z \"\$VOLUMES\" ]; then
                echo 'Using volumes from previous container:'
                for VOLUME in \$VOLUMES; do
                  echo '  - '\$VOLUME
                  VOLUME_ARGS=\"\$VOLUME_ARGS -v \$VOLUME\"
                done
              else
                echo 'No volumes found in configuration file'
              fi
            else
              echo 'No volume configuration file found'
            fi

            # Debug container deployment
            echo 'Available images:'
            docker images

            # Run the new container with the correct image name and explicit platform
            echo 'Running container with the locally tagged image: ${{ env.DOCKERHUB_REPO }}:'\${TIMESTAMP}

            # Debug: Confirm the locally tagged image exists before trying to use it
            echo 'Confirming image exists:'
            # Check if image exists
            IMAGE_EXISTS=0
            docker images "${{ env.DOCKERHUB_REPO }}:\${TIMESTAMP}" --quiet | grep -q . || IMAGE_EXISTS=1

            # Check if image exists using our helper script result
            if [ "\$IMAGE_EXISTS" -eq 0 ]; then
              echo 'Image found locally, proceeding with deployment'

              docker run --platform=linux/arm64 -d \
                --name balanced-app-new \
                --restart unless-stopped \
                -p 3000:\$NEW_PORT \
                -e DATABASE_URL='$DATABASE_URL' \
                -e NEXTAUTH_SECRET='$NEXTAUTH_SECRET' \
                -e NEXTAUTH_URL='$NEXTAUTH_URL' \
                \$VOLUME_ARGS \
                ${{ env.DOCKERHUB_REPO }}:\${TIMESTAMP}

              if [ $? -eq 0 ]; then
                echo 'Container started successfully'
              else
                echo 'Error starting container'
                exit 1
              fi
            else
              echo '[ERROR] Tagged image not found locally. This likely indicates a problem with the tagging step.'
              echo 'Available images:'
              docker images
              exit 1
            fi

            # Verify container was created successfully
            echo 'New container created:'
            docker ps | grep balanced-app-new
          "
          echo "New container deployment completed"

      - name: Health check and finalize deployment
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          echo "Running health check and finalizing deployment"

          # Verify the new container is healthy before completing the deployment
          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "set -e
            # First check if container is running
            echo 'Checking container status...'
            if ! docker ps | grep -q balanced-app-new; then
              echo '[ERROR] Container is not running'
              echo 'Container logs:'
              docker logs balanced-app-new 2>/dev/null || echo 'No logs available'
              echo 'Deployment failed - container failed to start properly'
              docker rm -f balanced-app-new 2>/dev/null || true
              exit 1
            fi

            echo 'Container is running, checking health...'

            # Get port mapping info
            NEW_PORT=\$(cat /tmp/new_port 2>/dev/null || echo '3000')
            echo 'Container mapped to internal port: '\$NEW_PORT

            # Wait for the application to be ready
            echo 'Waiting for application to become available (60s timeout)...'
            TIMEOUT_SEC=60
            WAIT_INTERVAL=5
            START_TIME=\$(date +%s)
            END_TIME=\$((START_TIME + TIMEOUT_SEC))
            CURRENT_TIME=\$START_TIME

            # More reliable health check - first try direct curl
            while [ \$CURRENT_TIME -lt \$END_TIME ]; do
              if curl -s http://localhost:\$NEW_PORT/ -o /dev/null; then
                echo 'Application is responding on port '\$NEW_PORT
                APP_READY=true
                break
              fi

              # Show container status at intervals
              ELAPSED=\$((CURRENT_TIME - START_TIME))
              REMAINING=\$((TIMEOUT_SEC - ELAPSED))

              if [ \$((ELAPSED % 15)) -eq 0 ]; then
                echo 'Container status:'
                # Using heredoc to protect Docker template syntax
                cat << 'EOT' > /tmp/container_status.sh
                #!/bin/bash
                docker ps --filter name=balanced-app-new --format '{{.Status}}'
                EOT
                chmod +x /tmp/container_status.sh
                /tmp/container_status.sh
                rm /tmp/container_status.sh

                echo 'Recent container logs:'
                docker logs --tail=10 balanced-app-new 2>/dev/null || echo 'No logs available'
              fi

              echo "Waiting for service (\${REMAINING}s remaining)..."
              sleep \$WAIT_INTERVAL
              CURRENT_TIME=\$(date +%s)
            done

            # Finalize deployment if health check passed
            if [ "\${APP_READY:-false}" = "true" ]; then
              echo '[SUCCESS] Health check passed!'

              # Clean up old container if it exists
              if [ -f /tmp/current_container_id ]; then
                CURRENT_CONTAINER=\$(cat /tmp/current_container_id)
                echo 'Stopping previous container: '\$CURRENT_CONTAINER

                # Stop with timeout and remove
                docker stop --time=10 \$CURRENT_CONTAINER || true
                docker rm \$CURRENT_CONTAINER || echo '[WARNING] Could not remove old container'
                echo 'Old container removed'
              else
                echo 'No previous container found'
              fi

              # Rename new container to standard name
              echo 'Setting new container as primary'
              docker rename balanced-app-new balanced-app
              if [ \$? -eq 0 ]; then
                echo '[SUCCESS] DEPLOYMENT SUCCESSFUL'
                echo 'Application is now running'
              else
                echo '[WARNING] Could not rename container - verify manually'
                # Don't fail the build for rename issue
              fi
            else
              # Health check initially failed - try additional attempts
              echo '[WARNING] Initial health check failed - attempting extended checks'
              
              # Try additional health checks with longer timeouts
              EXTENDED_ATTEMPTS=3
              for attempt in \$(seq 1 \$EXTENDED_ATTEMPTS); do
                echo "Extended health check attempt \$attempt of \$EXTENDED_ATTEMPTS"
                
                # Check if Prisma/database connection is the issue
                echo "Checking database connectivity..."
                if docker exec balanced-app-new /bin/sh -c "cd /app && npx prisma migrate status" &>/dev/null; then
                  echo "Database appears to be connected, waiting longer for app startup"
                else
                  echo "Database connection issues detected"
                fi
                
                # Wait longer between extended checks
                sleep 30
                
                # Try health check again
                if curl -s http://localhost:\$NEW_PORT/ -o /dev/null; then
                  echo '[RECOVERED] Application is now responding on port '\$NEW_PORT
                  APP_READY=true
                  break
                fi
              done
              
              # Final decision based on extended checks
              if [ "\${APP_READY:-false}" = "true" ]; then
                echo '[SUCCESS] Extended health check passed!'
                # Now continue with container rename logic as in the success path
                # Clean up old container if it exists
                if [ -f /tmp/current_container_id ]; then
                  CURRENT_CONTAINER=\$(cat /tmp/current_container_id)
                  echo 'Stopping previous container: '\$CURRENT_CONTAINER

                  # Stop with timeout and remove
                  docker stop --time=10 \$CURRENT_CONTAINER || true
                  docker rm \$CURRENT_CONTAINER || echo '[WARNING] Could not remove old container'
                  echo 'Old container removed'
                else
                  echo 'No previous container found'
                fi

                # Rename new container to standard name
                echo 'Setting new container as primary'
                docker rename balanced-app-new balanced-app
                if [ \$? -eq 0 ]; then
                  echo '[SUCCESS] DEPLOYMENT SUCCESSFUL'
                  echo 'Application is now running'
                else
                  echo '[WARNING] Could not rename container - verify manually'
                  # Don't fail the build for rename issue
                fi
              else
                # All attempts failed - collect debug info and clean up
                echo '[ERROR] ALL HEALTH CHECKS FAILED: Application did not respond within extended timeout'
                echo 'Container status:'
                docker ps -a --filter name=balanced-app-new

                echo 'Complete container logs:'
                docker logs balanced-app-new
                
                # Check for common issues
                echo 'Checking for common startup issues:'
                docker logs balanced-app-new 2>&1 | grep -i "error\|exception\|failed" || echo "No common error patterns found"

                echo 'Cleaning up failed deployment...'
                docker stop balanced-app-new || true
                docker rm balanced-app-new || true
                echo '[ERROR] DEPLOYMENT FAILED - cleanup complete'
                exit 1
              fi
            fi
          "

      - name: Cleanup
        if: always() # Run cleanup even if previous steps fail
        env:
          PI_USERNAME: ${{ secrets.PI_USERNAME }}
          PI_CLOUDFLARE_HOSTNAME: ${{ secrets.PI_CLOUDFLARE_HOSTNAME }}
        run: |
          echo "Performing post-deployment cleanup"

          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h" \
              $PI_USERNAME@$PI_CLOUDFLARE_HOSTNAME "
            echo 'Running post-deployment cleanup...'

            # Remove temporary image file if it exists
            rm -f /tmp/balanced-image.tar

            # Clean up all temporary files
            echo 'Removing temporary files'
            rm -f /tmp/deploy_timestamp /tmp/new_port /tmp/old_port /tmp/container_volumes /tmp/current_container_id

            # Clean up old images (keep only the 3 most recent)
            echo 'Cleaning up old Docker images (keeping 3 most recent)'
            REPO='${{ env.DOCKERHUB_REPO }}'

            # Use heredoc approach for Docker template syntax
            cat << 'EOT' > /tmp/list_tags.sh
            #!/bin/bash
            # Get tags using Docker's native template formatting
            docker images "$1" --format '{{.Tag}}' | grep -v 'latest' | grep -v '<none>' | sort -r
            EOT
            chmod +x /tmp/list_tags.sh
            TAGS=\$(/tmp/list_tags.sh "\$REPO")
            rm /tmp/list_tags.sh
            COUNT=\$(echo "\$TAGS" | wc -l)

            if [ \$COUNT -gt 3 ]; then
              echo "Found \$COUNT tags, removing old ones"
              echo "\$TAGS" | tail -n +4 | xargs -r -I {} docker rmi \$REPO:{} 2>/dev/null || true
              echo 'Image cleanup completed'
            else
              echo "Only \$COUNT tagged images found, no cleanup needed"
            fi

            # General cleanup of dangling images
            echo 'Removing any dangling images'
            docker image prune -f

            echo 'Cleanup completed successfully'
          "
